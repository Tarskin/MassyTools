#! /usr/bin/env python
import itertools
import math
import matplotlib.pyplot as plt

# The analyte that we will calculate the pattern for
Analyte = ['H5N4E1free1sodium1neg_electron1']


# Building block properties
BLOCKS = {	'F':{'mass':146.05790879894,
				'carbons':6,
				'hydrogens':10,
				'nitrogens':0,
				'oxygens':4,
				'sulfurs':0},
			'H':{'mass':162.0528234185,
				'carbons':6,
				'hydrogens':10,
				'nitrogens':0,
				'oxygens':5,
				'sulfurs':0},
			'N':{'mass':203.07937251951,
				'carbons':8,
				'hydrogens':13,
				'nitrogens':1,
				'oxygens':5,
				'sulfurs':0},
			'S':{'mass':291.09541650647,
				'carbons':11,
				'hydrogens':17,
				'nitrogens':1,
				'oxygens':8,
				'sulfurs':0},
			'L':{'mass':273.08485182277,
				'carbons':11,
				'hydrogens':15,
				'nitrogens':1,
				'oxygens':7,
				'sulfurs':0},
			'M':{'mass':305.11106657061,
				'carbons':12,
				'hydrogens':19,
				'nitrogens':1,
				'oxygens':8,
				'sulfurs':0},
			'E':{'mass':319.12671663475,
				'carbons':13,
				'hydrogens':21,
				'nitrogens':1,
				'oxygens':8,
				'sulfurs':0},
			'aa':{'mass':139.06332853255,
				'carbons':7,
				'hydrogens':9,
				'nitrogens':1,
				'oxygens':2,
				'sulfurs':0},
			'free':{'mass':18.0105646837,
				'carbons':0,
				'hydrogens':2,
				'nitrogens':0,
				'oxygens':1,
				'sulfurs':0},
			'proton':{'mass':1.007276466812,
				'carbons':0,
				'hydrogens':0,
				'nitrogens':0,
				'oxygens':0,
				'sulfurs':0},
			'neg_proton':{'mass':-1.007276466812,
				'carbons':0,
				'hydrogens':0,
				'nitrogens':0,
				'oxygens':0,
				'sulfurs':0},
			'sodium':{'mass':22.9897692809,
				'carbons':0,
				'hydrogens':0,
				'nitrogens':0,
				'oxygens':0,
				'sulfurs':0},
			'potassium':{'mass':38.96370668,
				'carbons':0,
				'hydrogens':0,
				'nitrogens':0,
				'oxygens':0,
				'sulfurs':0},
			'electron':{'mass':0.00054857990946,
				'carbons':0,
				'hydrogens':0,
				'nitrogens':0,
				'oxygens':0,
				'sulfurs':0},
			'neg_electron':{'mass':-0.00054857990946,
				'carbons':0,
				'hydrogens':0,
				'nitrogens':0,
				'oxygens':0,
				'sulfurs':0},
			'O':{'mass':15.9949146,
				'carbons':0,
				'hydrogens':0,
				'nitrogens':0,
				'oxygens':1,
				'sulfurs':0},
			'P':{'mass':79.966333,
				'carbons':0,
				'hydrogens':1,
				'nitrogens':0,
				'oxygens':3,
				'sulfurs':0},
			'Su':{'mass':79.956817,
				'carbons':0,
				'hydrogens':0,
				'nitrogens':0,
				'oxygens':3,
				'sulfurs':1},
			# Four of Albert's Peptides
			'Q':{'mass':4135.882086,
				'carbons':177,
				'hydrogens':270,
				'nitrogens':50,
				'oxygens':59,
				'sulfurs':0},
			'R':{'mass':2962.590442,
				'carbons':128,
				'hydrogens':219,
				'nitrogens':37,
				'oxygens':41,
				'sulfurs':1},
			'T':{'mass':2346.1348023,
				'carbons':101,
				'hydrogens':163,
				'nitrogens':27,
				'oxygens':33,
				'sulfurs':2},
			'U':{'mass':2183.0709257,
				'carbons':92,
				'hydrogens':154,
				'nitrogens':26,
				'oxygens':33,
				'sulfurs':2},
			'I':{'mass':1188.5047,
				'carbons':50,
				'hydrogens':72,
				'nitrogens':14,
				'oxygens':20,
				'sulfurs':0}}
UNITS = BLOCKS.keys()

# The maximum distance between distinct isotopic masses to be 'pooled'
EPSILON = 0.5

# Mass Differences
C = [('13C',0.0107,1.00335)]
H = [('2H',0.00012,1.00628)]
N = [('15N',0.00364,0.99703)]
O18 = [('18O',0.00205,2.00425)]
O17 = [('17O',0.00038,1.00422)]
S33 = [('33S',0.0076,0.99939)]
S34 = [('34S',0.0429,1.9958)]
S36 = [('36S',0.0002,3.99501)]

# Calculate the fraction of elements in isotope X based on a binom dist.
def calcDistribution(element, number):
	fractions = []
	for count,i in enumerate(element):
		fTotal = 0
		for j in range(0,10):	
			nCk = math.factorial(number) / (math.factorial(j) * math.factorial(number - j))
			f = nCk * i[1]**j * (1 - i[1])**(number-j)
			fTotal += f
			fractions.append((i[2]*j,f))
			if fTotal > 0.99:
				break
	return fractions
	
# Call the function
def parseAnalyte(Analyte):
	results = []		
	for i in Analyte:
		mass = 0
		numCarbons = 0
		numHydrogens = 0
		numNitrogens = 0
		numOxygens = 0
		numSulfurs = 0
		totalElements = 0
		units = ["".join(x) for _,x in itertools.groupby(i,key=str.isdigit)]
		for index,j in enumerate(units):
			for k in UNITS:
					if j == k:
						mass += float(BLOCKS[k]['mass']) * float(units[index+1])
						numCarbons += int(BLOCKS[k]['carbons']) * int(units[index+1])
						numHydrogens += int(BLOCKS[k]['hydrogens']) * int(units[index+1])
						numNitrogens += int(BLOCKS[k]['nitrogens']) * int(units[index+1])
						numOxygens += int(BLOCKS[k]['oxygens']) * int(units[index+1])
						numSulfurs += int(BLOCKS[k]['sulfurs']) * int(units[index+1])
		# Calculate the distribution for the given value
		carbons = calcDistribution(C,numCarbons)
		hydrogens = calcDistribution(H,numHydrogens)
		nitrogens = calcDistribution(N,numNitrogens)
		oxygens17 = calcDistribution(O17,numOxygens)
		oxygens18 = calcDistribution(O18,numOxygens)
		sulfurs33 = calcDistribution(S33,numSulfurs)
		sulfurs34 = calcDistribution(S34,numSulfurs)
		sulfurs36 = calcDistribution(S36,numSulfurs)
	return ((mass,carbons,hydrogens,nitrogens,oxygens17,oxygens18,sulfurs33,sulfurs34,sulfurs36))
				
# Calculate the chance network
def getChanceNetwork((mass,carbons,hydrogens,nitrogens,oxygens17,oxygens18,sulfurs33,sulfurs34,sulfurs36)):
	totals = []
	for x in itertools.product(carbons,hydrogens,nitrogens,oxygens17,oxygens18,sulfurs33,sulfurs34,sulfurs36):
		i, j, k, l, m, n, o, p = x
		totals.append((mass+i[0]+j[0]+k[0]+l[0]+m[0]+n[0]+o[0]+p[0],
					   i[1]*j[1]*k[1]*l[1]*m[1]*n[1]*o[1]*p[1]))
	return totals

# Merge the peaks based on specified 'Epsilon'
def mergeChances(totals):
	results = []
	newdata = {d: True for d in totals}
	for k, v in totals:
		if not newdata[(k,v)]: continue
		newdata[(k,v)] = False
		# use each piece of data only once
		keys,values = [k*v],[v]
		for kk, vv in [d for d in totals if newdata[d]]:
			if abs(k-kk) < EPSILON:
				keys.append(kk*vv)
				values.append(vv)
				newdata[(kk,vv)] = False
		results.append((sum(keys)/sum(values),sum(values)))
	return results

# Display the data
def displayIsotopicPattern(results):
	minVal = 10000
	maxVal = 0
	for i in results:
		if i[0] < minVal:
			minVal = i[0]
		if i[0] > maxVal:
			maxVal = i[0]
		plt.plot((i[0],i[0]),(0,i[1]),c='black')
	plt.plot((minVal,maxVal),(0,0),c='black')
	plt.show()

# Main
def main():
	distributions = parseAnalyte(Analyte)
	totals = getChanceNetwork(distributions)
	results = mergeChances(totals)
	displayIsotopicPattern(results)
	
if __name__ == "__main__":
	main()
